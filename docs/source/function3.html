<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * Created with JetBrains RubyMine.
 * User: i061485
 * Date: 5/16/13
 * Time: 2:54 PM
 * To change this template use File | Settings | File Templates.
 */

(function addFunctionMethods() {

    (function bindFunction() {
        if (!Function.prototype.bind) {
<span id='global-method-bind'>            /**
</span>             * Function Bind method
             * @param context
             * @returns {*}
             */
            Function.prototype.bind = function bound(context) {
                if (typeof this !== &#39;function&#39;) {
                    // closest thing possible to the ECMAScript 5 internal IsCallable function
                    throw new TypeError(&#39;Function.prototype.bind - what is trying to be fBound is not callable&#39;);
                }
                // Callee
                var fn = this;
                var bindFn;
                // If no custom arguments bound -&gt; use &#39;light&#39; bound version
                if (arguments.length &lt; 2) {
                    bindFn = function lightBind() {
                        if (!arguments.length) {
                            return fn.call(context);
                        }
                        return fn.apply(context, arguments);
                    };
                } else {
                    // Else -&gt; use &#39;heavy&#39; bound version
                    var fnSlice = Array.prototype.slice;
                    var args = (arguments.length &gt; 1) &amp;&amp; fnSlice.call(arguments, 1);
                    bindFn = function heavyBind() {
                        if (arguments.length) {
                            return fn.apply(context, args.concat(fnSlice.call(arguments)));
                        }
                        return fn.apply(context, args);
                    };
                }
                bindFn.displayName = fn.displayName || fn.name;
                return bindFn;
            };
            return true;
        }
        return false;
    }());
// http://www.crockford.com/javascript/inheritance.html

// First, the method method, which adds an instance method to a class.
// This adds a public method to the Function.prototype, so all functions get it by
// Class Augmentation.
// It takes a name and a function, and adds them to a function&#39;s prototype object.
// It returns this.

<span id='global-method-method'>    /**
</span>     * Function add Method
     * @param {string} name
     * @param {function} func
     * @returns {Function}
     */
    Function.prototype.method = function method(name, func) {
        this.prototype[name] = func;
        return this;
    };

// Next comes the inherits method, which indicates that one class inherits from another.
// It should be called after both classes are defined, but before the inheriting class&#39;s
// methods are added.
// Again, we augment Function. We make an instance of the parent class and use it as the
// new prototype. We also correct the constructor field, and we add the uber method to
// the prototype as well.
// The uber method looks for the named method in its own prototype. This is the function
// to invoke in the case of Parasitic Inheritance or Object Augmentation.
// If we are doing Classical Inheritance, then we need to find the function in the
// parent&#39;s prototype.
// The return statement uses the function&#39;s apply method to invoke the function,
// explicitly setting this and passing an array of parameters. The parameters (if any)
// are obtained from the arguments array. Unfortunately, the arguments array is not a
// true array, so we have to use apply again to invoke the array slice method.

    Function.method(&#39;inherits&#39;, function inherits(Parent) {
        var d = {},
            p = (this.prototype[Parent.name.toLowerCase()] = new Parent());
        this.method(&#39;uber&#39;, function uber(name) {
            if (!d.hasOwnProperty(name)) {
                d[name] = 0;
            }
            var f, r, t = d[name], v = Parent.prototype;
            if (t) {
                while (t) {
                    v = v.constructor.prototype;
                    t -= 1;
                }
                f = v[name];
            } else {
                f = p[name];
                if (f === this[name]) {
                    f = v[name];
                }
            }
            d[name] += 1;
            r = f.apply(this, Array.prototype.slice.apply(arguments, [1]));
            d[name] -= 1;
            return r;
        });
        return this;
    });

// The swiss method loops through the arguments. For each name, it copies a
// member from the parent&#39;s prototype to the new class&#39;s prototype.
    Function.method(&#39;swiss&#39;, function swiss(Parent) {
        var i, l = arguments.length;
        for (i = 1; i &lt; l; i += 1) {
            var name = arguments[i];
            this.prototype[name] = Parent.prototype[name];
        }
        return this;
    });

<span id='global-property-'>    /**
</span>     * Get Function name
     */
    if (Function.prototype.name === undefined &amp;&amp; Object.defineProperty !== undefined) {
        Object.defineProperty(Function.prototype, &#39;name&#39;, {
<span id='global-method-get'>            /**
</span>             * Get function name
             * @returns {String}
             */
            get: function get() {
                var funcNameRegex = /function\s+(.{1,})\s*\(/,
                    results = (funcNameRegex).exec((this).toString()),
                    aliases = [&quot;&quot;, &quot;anonymous&quot;, &quot;Anonymous&quot;],
                    cname = (results &amp;&amp; results.length &gt; 1) ? results[1] : &quot;&quot;;

                return aliases.indexOf(cname) &gt; -1 ? &quot;Function&quot; : cname;
            },
            set: function set(value) {
            }
        });
    }

<span id='global-property-'>    /**
</span>     * Get Function Caller name
     */
    Function.method(&#39;getCallerName&#39;, function getCallerName() {
        var cfn = this.caller;
        return typeof cfn === &#39;function&#39; ? cfn.name : null;
    });

<span id='global-property-'>    /**
</span>     * Extend Function prototype
     */
    Function.method(&#39;extend&#39;, function extend() {
        var i = 0, l = arguments.length;

        function extendMethod(node) {
            if (typeof node === &#39;function&#39;) {
                var self = {};
                $.extend(true, self, this.prototype);
                this.inherits(node);
                $.extend(true, this.prototype, self);
            } else {
                $.extend(true, this.prototype, node);
            }
        }

        for (i; i &lt; l; i += 1) {
            extendMethod.bind(this)(arguments[i]);
        }

        return this;
    });

}());</pre>
</body>
</html>
